<!DOCTYPE html>
<html lang="{{ .Site.LanguageCode }}">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>{{ .Title }} | {{ .Site.Title }}</title>
    <script>
        // Set theme before page renders to prevent flash
        (function() {
            const saved = localStorage.getItem('theme');
            const theme = saved || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
            if (theme === 'dark') {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.add('light');
            }
        })();
    </script>
    {{ partial "head.html" . }}
</head>
<body class="antialiasing text-slate-700">
    <div id="search-backdrop" class="search-backdrop"></div>
    <div id="search-results" class="search-results-overlay"></div>
    {{ partial "header.html" . }}
    <script>
    // Sync --header-height CSS variable with actual header size
    (function() {
        function sync() {
            var h = document.querySelector('header');
            if (h) document.documentElement.style.setProperty('--header-height', h.offsetHeight + 'px');
        }
        sync();
        window.addEventListener('resize', sync);
    })();
    </script>

    <div class="content-wrapper">
        <div class="content-columns">
            {{ block "main" . }}{{ end }}
        </div>
        {{ partial "footer.html" . }}
    </div>

    <script>
    // Dark Mode Toggle with System Preference Detection
    (function() {
        const toggle = document.getElementById('dark-mode-toggle');
        const html = document.documentElement;
        const sunIcon = toggle.querySelector('.sun-icon');
        const moonIcon = toggle.querySelector('.moon-icon');
        const themeLabel = toggle.querySelector('.theme-label');

        // Check for saved preference or system preference
        function getThemePreference() {
            const saved = localStorage.getItem('theme');
            if (saved) {
                return saved;
            }
            // Detect system preference
            return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        }

        function setTheme(theme) {
            if (theme === 'dark') {
                html.classList.add('dark');
                html.classList.remove('light');
                sunIcon.classList.remove('hidden');
                moonIcon.classList.add('hidden');
                if (themeLabel) themeLabel.textContent = 'Light theme';
            } else {
                html.classList.remove('dark');
                html.classList.add('light');
                sunIcon.classList.add('hidden');
                moonIcon.classList.remove('hidden');
                if (themeLabel) themeLabel.textContent = 'Dark theme';
            }
            localStorage.setItem('theme', theme);
        }

        // Initialize theme on page load
        const currentTheme = getThemePreference();
        setTheme(currentTheme);

        // Toggle theme on button click
        toggle.addEventListener('click', function() {
            const newTheme = html.classList.contains('dark') ? 'light' : 'dark';
            setTheme(newTheme);
        });

        // Listen for system theme changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', function(e) {
            // Only auto-switch if user hasn't manually set a preference
            if (!localStorage.getItem('theme')) {
                setTheme(e.matches ? 'dark' : 'light');
            }
        });
    })();
    </script>

    <script>
    // Sidebar collapse/expand
    document.querySelectorAll('.sidebar-section-toggle').forEach(function(btn) {
        btn.addEventListener('click', function() {
            var content = btn.nextElementSibling;
            var chevron = btn.querySelector('.sidebar-chevron');
            var isExpanded = btn.getAttribute('aria-expanded') === 'true';

            if (isExpanded) {
                content.classList.add('hidden');
                btn.setAttribute('aria-expanded', 'false');
                chevron.classList.remove('rotate-180');
            } else {
                content.classList.remove('hidden');
                btn.setAttribute('aria-expanded', 'true');
                chevron.classList.add('rotate-180');
            }
        });
    });
    </script>

    <script>
    // Copy to clipboard functionality for code blocks
    document.addEventListener('DOMContentLoaded', function() {
        document.querySelectorAll('.highlight').forEach(function(wrapper) {
            var pre = wrapper.querySelector('pre');
            if (!pre) return;

            var btn = document.createElement('button');
            btn.className = 'copy-btn';
            btn.setAttribute('aria-label', 'Copy code');
            btn.innerHTML = '<svg class="copy-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg><svg class="check-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg>';
            wrapper.appendChild(btn);

            btn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                if (code) {
                    navigator.clipboard.writeText(code.textContent).then(function() {
                        btn.classList.add('copied');
                        setTimeout(function() { btn.classList.remove('copied'); }, 2000);
                    });
                }
            });
        });
    });
    </script>

    <script>
    // Couper-specific HCL syntax post-processor
    // Enhances Chroma's output with Couper variable, function, and property highlighting
    document.addEventListener('DOMContentLoaded', function() {
        var s = window.__couper_syntax;
        if (!s) return;
        // Exact match regex for span text (strip \b word boundaries, anchor with ^...$)
        var varRe = new RegExp('^' + s.varPattern.replace(/\\b/g, '') + '$');
        // Unanchored regex for matching variables inside template interpolation
        var varInline = new RegExp(s.varPattern.replace(/\\b/g, ''));
        document.querySelectorAll('.highlight code').forEach(function(code) {
            // Fix // comments misclassified as errors by Chroma's HCL lexer
            code.querySelectorAll('span.err').forEach(function(sp) {
                if (sp.textContent.trim().indexOf('//') === 0) {
                    sp.classList.remove('err');
                    sp.classList.add('c1');
                    // Restyle remaining siblings on the same line as comment
                    var node = sp.nextSibling;
                    while (node && !(node.nodeType === 3 && node.textContent.indexOf('\n') !== -1)) {
                        if (node.nodeType === 1) node.classList.add('c1');
                        node = node.nextSibling;
                    }
                }
            });

            var spans = code.querySelectorAll('span');
            for (var i = 0; i < spans.length; i++) {
                var sp = spans[i];
                if (sp.children.length > 0) continue;
                var t = sp.textContent;

                if (varRe.test(t)) {
                    // Only mark as variable if followed by . (property access = expression context)
                    // This avoids coloring block type declarations like: backend "name" {
                    var nxEl = sp.nextElementSibling;
                    if (nxEl && nxEl.textContent === '.') {
                        sp.classList.add('couper-var');
                    }
                } else {
                    // Function call: any identifier followed by (
                    var nx = sp.nextSibling;
                    while (nx && nx.nodeType === 3 && nx.textContent.trim() === '') nx = nx.nextSibling;
                    if (nx && (nx.textContent || '').charAt(0) === '(') {
                        sp.classList.add('couper-fn');
                    }
                    // Property: preceded by dot after a couper-var or couper-prop
                    var prev = sp.previousElementSibling;
                    if (prev && prev.textContent === '.') {
                        var pp = prev.previousElementSibling;
                        if (pp && (pp.classList.contains('couper-var') || pp.classList.contains('couper-prop'))) {
                            sp.classList.add('couper-prop');
                        }
                    }
                }
            }

            // Second pass: enhance template interpolation inside string and name spans
            code.querySelectorAll('span.s2, span.s, span.s1, span.sh, span.n, span.k').forEach(function(sp) {
                if (sp.children.length > 0 || sp.innerHTML.indexOf('${') === -1) return;
                sp.innerHTML = sp.innerHTML.replace(/\$\{(~?)([\w.-]+)(~?)\}/g, function(m, tl, expr, tr) {
                    var parts = expr.split('.');
                    var result = parts.map(function(part, idx) {
                        if (idx === 0 && varInline.test(part)) {
                            return '<span class="couper-var">' + part + '</span>';
                        } else if (idx > 0 && parts[0].match(varInline)) {
                            return '<span class="couper-prop">' + part + '</span>';
                        }
                        return part;
                    }).join('.');
                    return '<span class="couper-interp">${' + tl + '</span>' + result + '<span class="couper-interp">' + tr + '}</span>';
                });
            });
        });
    });
    </script>

    <script>
    // Enhance "Note:" blockquotes with icon class
    document.querySelectorAll('.prose blockquote').forEach(function(bq) {
        var p = bq.querySelector('p');
        if (p && p.textContent.trimStart().indexOf('Note:') === 0) {
            bq.classList.add('note-blockquote');
            // Wrap "Note:" in a <strong> for styling
            p.innerHTML = p.innerHTML.replace(/^(\s*)Note:/, '$1<strong>Note:</strong>');
        }
    });
    </script>

    <script>
    // Algolia Search Configuration
    const ALGOLIA_APP_ID = 'MSIN2HU7WH';
    const ALGOLIA_SEARCH_KEY = '5551c3e4dfb61914988abf95fd9b762f'; // Search-only API key
    const ALGOLIA_INDEX = 'docs';

    if (typeof algoliasearch !== 'undefined' && typeof instantsearch !== 'undefined') {
        const searchClient = algoliasearch(ALGOLIA_APP_ID, ALGOLIA_SEARCH_KEY);

        // Wrapper to prevent empty queries
        const customSearchClient = {
            ...searchClient,
            search(requests) {
                if (requests.every(({ params }) => !params.query || params.query === '')) {
                    return Promise.resolve({
                        results: requests.map(() => ({
                            hits: [],
                            nbHits: 0,
                            nbPages: 0,
                            page: 0,
                            processingTimeMS: 0,
                        })),
                    });
                }
                return searchClient.search(requests);
            },
        };

        const search = instantsearch({
            indexName: ALGOLIA_INDEX,
            searchClient: customSearchClient,
            stalledSearchDelay: 150,
        });

        // Add search box widget
        search.addWidgets([
            instantsearch.widgets.searchBox({
                container: '#searchbox',
                placeholder: 'Search documentation...',
                cssClasses: {
                    root: 'w-full',
                    form: 'w-full relative',
                    input: 'block p-2.5 pl-10 w-full text-sm text-gray-900 rounded-lg border border-slate-300 focus:ring-sky-500 focus:border-sky-500 bg-white',
                    submit: 'hidden',
                    reset: '',
                },
            }),
        ]);

        // Custom hits widget with transformation
        const renderHits = (renderOptions, isFirstRender) => {
            const { hits, widgetParams } = renderOptions;

            if (hits.length === 0) {
                widgetParams.container.innerHTML = '';
                return;
            }

            // Transform items (similar to Vue component)
            const transformedHits = hits.map(item => {
                if (item._highlightResult && item._highlightResult.attributes) {
                    item._highlightResult.attributes.forEach(attr => {
                        if (attr.description && !attr.transformed) {
                            let description = attr.description.value;
                            // do not mark markdown _highlights_ as search hits
                            description = description.replace(/\b_(.*?)_\b/g, '$1');
                            // drop link markdown
                            description = description.replace(/\[(.*?)\]\(.*?\)/g, '$1');
                            // render code markdown
                            description = description.replace(/`(.*?)`/g, '<code>$1</code>');
                            attr.description.value = description;
                            attr.transformed = true;
                        }
                    });
                }
                return item;
            });

            // Filter and sort hits
            const filteredHits = transformedHits
                .filter(item => item._highlightResult !== undefined)
                .sort((a, b) => (a.__position > b.__position ? 1 : -1));

            // Render results
            widgetParams.container.innerHTML = filteredHits
                .map(item => {
                    const name = item._highlightResult?.name?.value || item.name || '';
                    const description = item._highlightResult?.description?.value || item.description || '';
                    const url = (item.url || '').toLowerCase();

                    // Filter attributes with matches
                    const matchedAttrs = (item._highlightResult?.attributes || [])
                        .filter(attr =>
                            (attr.name?.matchedWords?.length > 0) ||
                            (attr.description?.matchedWords?.length > 0)
                        )
                        .map(attr => ({
                            name: attr.name?.value || '',
                            desc: attr.description?.value || ''
                        }));

                    const attrsHtml = matchedAttrs.length > 0
                        ? `<table class="table-auto w-full mt-1 text-sm">
                            <tbody>
                                ${matchedAttrs.map(attr => `
                                    <tr class="align-top">
                                        <td class="font-semibold search-attr-name w-1/3 py-0.5">${attr.name}</td>
                                        <td class="py-0.5">${attr.desc}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                           </table>`
                        : '';

                    return `
                        <div class="search-card rounded-md w-full mt-1.5">
                            <a href="${url}" class="block">
                                <div class="px-4 py-2.5 cursor-pointer search-card-inner rounded-md">
                                    <div class="search-result text-base">
                                        <h3 class="uppercase blockTitle text-base font-bold mb-0.5">${name}</h3>
                                        ${description ? `<p class="text-sm leading-snug opacity-70 mb-1 line-clamp-2">${description}</p>` : ''}
                                        ${attrsHtml}
                                    </div>
                                </div>
                            </a>
                        </div>
                    `;
                })
                .join('');
        };

        const customHits = instantsearch.connectors.connectHits(renderHits);

        search.addWidgets([
            customHits({
                container: document.querySelector('#search-results'),
            }),
        ]);

        search.start();

        // Toggle search backdrop when results appear/disappear
        const backdrop = document.getElementById('search-backdrop');
        const resultsEl = document.getElementById('search-results');
        if (backdrop && resultsEl) {
            new MutationObserver(() => {
                backdrop.classList.toggle('active', resultsEl.innerHTML.trim() !== '');
            }).observe(resultsEl, { childList: true, subtree: true });

            // Clicking the backdrop clears search
            backdrop.addEventListener('click', () => {
                const input = document.querySelector('.ais-SearchBox-input');
                if (input) input.value = '';
                resultsEl.innerHTML = '';
            });
        }

        // Clear results on blur
        document.addEventListener('click', (e) => {
            const searchBox = document.querySelector('#searchbox');
            const searchResults = document.querySelector('#search-results');
            if (searchBox && !searchBox.contains(e.target) && searchResults && !e.target.closest('#search-backdrop')) {
                setTimeout(() => {
                    const input = document.querySelector('.ais-SearchBox-input');
                    if (input) input.value = '';
                    searchResults.innerHTML = '';
                }, 200);
            }
        });
    }
    </script>
</body>
</html>
